好的，根据你的描述，我将你的需求整理成了一份**详细的技术方案规格说明书（Technical Specification）**。

这份方案将模糊的自然语言需求转化为严谨的代码逻辑，明确了输入、输出、业务规则以及 Agent 的工具调用策略。

---

### 1. 核心目标 (Core Objective)

构建一个**金融询价解析 Agent**，接收交易员非标准化的自然语言文本（询价），结合**当前时间上下文**，输出符合下游定价系统要求的**标准化 JSON 数据**。

* **约束：** 当前版本不支持追问/澄清（no human-in-the-loop）。当关键信息缺失或歧义无法消除时，只能做确定性推断或输出缺失标记，交由后处理拦截或补全。

---

### 2. 数据协议 (Data Protocol)

#### 2.1 输入 (Input)

* **Text:** 用户询价文本（例如：“hc10合约，我方卖一个月平值期权”）
* **Context:**
* `current_date`: 当前日期（用于计算到期日）
* `current_year`: 当前年份（用于推断合约年份）



#### 2.2 输出 (Output JSON Schema)

| 字段名 | 类型 | 值域 | 说明 |
| --- | --- | --- | --- |
| `contract_code` | `str \| null` | `"HC2610"` | **逻辑组合字段**：品种代码(大写) + 年份(2位) + 月份(2位)。若文本未提供且无法推断则为 `null`（由后处理拦截或补全）。 |
| `call_put` | `int \| null` | {`1`,`2`, `null`} | **权利方**：`1`=看涨(Call), `2`=看跌(Put)。若文本未提供且无法推断则为 `null`（由后处理拦截或补全）。 |
| `buy_sell` | `int \| null` | {`-1`,`1`, `null`} | **客户方向**：`1`=客户买入, `-1`=客户卖出 (需进行视角转换)。若文本歧义无法消除则为 `null`（不追问）。 |
| `strike` | `float \| null` | 大于0 | **绝对行权价**：与 `strike_offset` 互斥，二选一填入，另一个为 `null` |
| `strike_offset` | `float \| null` | 不限 | **相对行权价**：平值=0，虚/实值需定义正负号逻辑 |
| `underlying_price` | `float \| null` | 不限 | **入场参考价**：可选，未指定则为 `null` |
| `expire_date` | `str \| null` | `"2026-03-12"` | **到期日期**：格式 `YYYY-MM-DD`，由直接提取或工具计算得出。若文本未提供且无法推断则为 `null`（由后处理拦截或补全）。 |

---

### 3. 关键业务逻辑 (Business Logic)

#### A. 合约代码推断 (Contract Code Inference)

* **规则：** 用户通常只说月份（如 "hc10"），Agent 需补全年份。
* **逻辑：**
* 提取品种代码（如 `hc` -> `HC`）。
* 提取月份（如 `10`）。
* **年份判断：**
* 若 `目标月份 >= 当前月份`：年份 = `当前年份` (例如当前2月，目标10月 -> 2610)。
* 若 `目标月份 < 当前月份`：年份 = `当前年份 + 1` (例如当前11月，目标1月 -> 2701)。





#### B. 买卖方向转换 (Perspective Flip)

* **规则：** 系统字段定义为**“客户方向”**。
* **逻辑：**
* 若文本含 “客户买”、“买入” -> `1`。
* 若文本含 “客户卖”、“卖出” -> `-1`。
* 若文本含 “我方卖”、“我们卖”、“卖给你”、“offer” -> `1`（客户买入）。
* 若文本含 “我方买”、“我们买”、“从你买”、“bid” -> `-1`（客户卖出）。
* **冲突处理：** 若出现同时指向买/卖的关键词且无法消歧，则输出 `null`（不追问）。



#### C. 行权价互斥与符号 (Strike Logic)

* **规则：** `strike` 和 `strike_offset` 只能存在一个。
* **冲突处理：** 若同时出现 `strike` 和 `strike_offset`，优先保留 `strike`，并将 `strike_offset` 置为 `null`。
* **Offset 符号定义（需确认）：**
* 采用 **Moneyness (价内/价外)** 逻辑：
* 平值 (ATM) = `0`
* 实值 (ITM) / "实30" = `+30`
* 虚值 (OTM) / "虚30" = `-30`


#### C2. 看涨/看跌提取 (Call/Put Logic)

* **规则：** 看涨填 `1`，看跌填 `2`。
* **关键词示例：**
* 看涨/认购/Call/C -> `1`
* 看跌/认沽/Put/P -> `2`
* **缺失处理：** 若未出现任何可识别关键词且无法从上下文确定，则输出 `null`（不进行追问，不猜测）。


#### D. 到期日计算 (Expiration Logic)

* **绝对日期：** 用户说 "4月15到期" -> 结合当前年份，处理跨年逻辑 -> 输出 "2026-04-15"。
* **冲突处理：** 若同时出现绝对日期和相对期限，优先绝对日期。
* **相对日期（必须调用工具）：**
* "1个月" -> 调用 `get_expire_date_by_months(1)`。
* "20天" / "20日" -> 调用 `get_expire_date_by_natural_date(20)`。
* "20个交易日" -> 调用 `get_expire_date_by_trading_date(20)`。



---

### 4. Agent 架构与工具 (System Architecture)

我们将使用 **Tool-Calling Agent** 模式。

#### 4.1 涉及的工具 (Function Tools)

1. **`get_expire_date_by_months(months: float) -> str`**
* **场景：** 用户提到“月”为单位的期限。
* **功能：** 基于当前系统日期，向后推算自然月。支持小数（如 0.5个月）。


2. **`get_expire_date_by_natural_date(days: int) -> str`**
* **场景：** 用户提到“天”、“日”为单位的期限（自然日）。
* **功能：** 基于当前系统日期，向后推算自然日（不跳过周末/节假日）。


3. **`get_expire_date_by_trading_date(days: int) -> str`**
* **场景：** 用户提到“交易日”为单位的期限（如“20个交易日”）。
* **功能：** 基于当前系统日期，向后推算交易日（跳过周末/节假日逻辑，节假日历来源需在实现中明确）。



#### 4.2 处理流程 (Pipeline)

1. **用户输入** ->
2. **预处理** (注入当前日期 Context) ->
3. **LLM 分析** (提取品种、方向、价格，判断期限类型) ->
4. **决策分支**：
* *分支A (含相对日期)* -> **调用 Tool** -> 获得日期 -> **生成 JSON**。
* *分支B (含绝对日期)* -> **直接计算** -> **生成 JSON**。


5. **后处理校验** (确保 `buy_sell` 是 int，`contract_code` 格式正确)。
* 若下游定价系统要求字段必填（例如 `call_put`、`expire_date`），建议在后处理阶段对 `null` 做硬拦截，避免错误下游定价。

---
