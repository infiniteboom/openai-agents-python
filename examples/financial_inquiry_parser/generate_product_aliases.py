from __future__ import annotations

import argparse
import json
import re
from pathlib import Path

SUPPORTED_CODE_PATTERN = re.compile(r"^[A-Za-z]{1,6}$")

# Common colloquial aliases not always present in source maps.
MANUAL_ALIASES: dict[str, str] = {
    "热卷": "HC",
    "螺纹": "RB",
}

NAME_SUFFIXES_TO_STRIP = (
    "指数期货",
    "期货",
)


def _canonical_code(raw_code: str) -> str | None:
    code = raw_code.strip()
    if not SUPPORTED_CODE_PATTERN.fullmatch(code):
        return None
    return code.upper()


def _derived_name_aliases(name: str) -> set[str]:
    aliases = {name}
    for suffix in NAME_SUFFIXES_TO_STRIP:
        if name.endswith(suffix):
            stripped = name[: -len(suffix)].strip()
            if stripped:
                aliases.add(stripped)

    # "热轧卷板" is commonly called "热卷" in RFQs.
    if "热轧卷板" in name:
        aliases.add(name.replace("热轧卷板", "热卷"))
        aliases.add("热卷")

    return aliases


def generate_product_aliases(input_path: Path) -> dict[str, str]:
    payload = json.loads(input_path.read_text(encoding="utf-8"))
    if not isinstance(payload, dict):
        raise ValueError(f"Expected a JSON object in {input_path}, got {type(payload).__name__}.")

    code_to_name: dict[str, str] = {}
    for raw_code, raw_name in payload.items():
        if not isinstance(raw_code, str) or not isinstance(raw_name, str):
            continue
        code = _canonical_code(raw_code)
        if code is None:
            continue
        name = raw_name.strip()
        if not name:
            continue
        code_to_name[code] = name

    alias_to_code: dict[str, str] = {}

    for code, name in sorted(code_to_name.items()):
        alias_to_code[code] = code
        for alias in sorted(_derived_name_aliases(name)):
            alias_to_code[alias] = code

    for alias, code in MANUAL_ALIASES.items():
        canonical = _canonical_code(code)
        if canonical is None:
            continue
        alias_to_code[alias] = canonical

    return dict(sorted(alias_to_code.items(), key=lambda item: item[0]))


def render_python_module(alias_to_code: dict[str, str], *, source_path: Path) -> str:
    mapping_lines = [f'    "{alias}": "{code}",' for alias, code in alias_to_code.items()]
    mapping_body = "\n".join(mapping_lines)
    return (
        "# Auto-generated by generate_product_aliases.py. Do not edit by hand.\n"
        f"# Source: {source_path}\n\n"
        "from __future__ import annotations\n\n"
        "PRODUCT_ALIAS_TO_CODE: dict[str, str] = {\n"
        f"{mapping_body}\n"
        "}\n"
    )


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Generate product alias -> product code mapping module."
    )
    parser.add_argument(
        "--input",
        type=Path,
        default=Path("variety_map.json"),
        help="Input JSON path containing {product_code: chinese_name} mapping.",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=Path("examples/financial_inquiry_parser/generated_product_aliases.py"),
        help="Output Python module path.",
    )
    args = parser.parse_args()

    aliases = generate_product_aliases(args.input)
    module_text = render_python_module(aliases, source_path=args.input)
    args.output.write_text(module_text, encoding="utf-8")
    print(f"Wrote python module to {args.output}")


if __name__ == "__main__":
    main()
