from __future__ import annotations

import argparse
import json
import re
from collections import defaultdict
from pathlib import Path
from typing import Literal

SIMPLE_CONTRACT_PATTERN = re.compile(r"^([A-Za-z]+)(\d+)$")
SUPPORTED_SUFFIX_LENGTHS = {3, 4}


def _suffix_format(lengths: set[int]) -> Literal["YMM", "YYMM", "MIXED"]:
    if lengths == {3}:
        return "YMM"
    if lengths == {4}:
        return "YYMM"
    return "MIXED"


def generate_rules(input_path: Path) -> dict[str, object]:
    rows = json.loads(input_path.read_text(encoding="utf-8"))
    if not isinstance(rows, list):
        raise ValueError(f"Expected a JSON list in {input_path}, got {type(rows).__name__}.")

    lengths_by_product: dict[str, set[int]] = defaultdict(set)
    samples_by_product: dict[str, list[str]] = defaultdict(list)
    varieties_by_product: dict[str, set[str]] = defaultdict(set)
    ignored_codes: list[str] = []

    for row in rows:
        if not isinstance(row, dict):
            continue

        contract_code = str(row.get("contractCode", "")).strip()
        variety_code = str(row.get("varietyCode", "")).strip().upper()
        m = SIMPLE_CONTRACT_PATTERN.fullmatch(contract_code)
        if not m:
            if contract_code:
                ignored_codes.append(contract_code)
            continue

        product = m.group(1).upper()
        suffix = m.group(2)
        suffix_len = len(suffix)
        if suffix_len not in SUPPORTED_SUFFIX_LENGTHS:
            ignored_codes.append(contract_code)
            continue

        lengths_by_product[product].add(suffix_len)
        varieties_by_product[product].add(variety_code)
        if len(samples_by_product[product]) < 3:
            samples_by_product[product].append(contract_code.upper())

    rules: dict[str, dict[str, object]] = {}
    for product in sorted(lengths_by_product):
        lengths = lengths_by_product[product]
        rules[product] = {
            "suffix_format": _suffix_format(lengths),
            "suffix_lengths": sorted(lengths),
            "variety_codes": sorted(v for v in varieties_by_product[product] if v),
            "sample_contracts": samples_by_product[product],
        }

    ymm_products = sorted(
        product for product, rule in rules.items() if rule["suffix_format"] == "YMM"
    )
    yymm_products = sorted(
        product for product, rule in rules.items() if rule["suffix_format"] == "YYMM"
    )
    mixed_products = sorted(
        product for product, rule in rules.items() if rule["suffix_format"] == "MIXED"
    )

    return {
        "source": str(input_path),
        "total_rows": len(rows),
        "matched_products": len(rules),
        "ignored_row_count": len(ignored_codes),
        "ignored_code_samples": ignored_codes[:20],
        "summary": {
            "YMM_count": len(ymm_products),
            "YYMM_count": len(yymm_products),
            "MIXED_count": len(mixed_products),
            "YMM_products": ymm_products,
            "MIXED_products": mixed_products,
        },
        "rules": rules,
    }


def render_python_module(rules_data: dict[str, object], *, source_path: Path) -> str:
    rules_obj = rules_data.get("rules")
    if not isinstance(rules_obj, dict):
        raise ValueError("rules_data['rules'] must be a dict.")

    suffix_format_by_product: dict[str, str] = {}
    for product, rule in rules_obj.items():
        if not isinstance(product, str) or not isinstance(rule, dict):
            continue
        suffix_format = rule.get("suffix_format")
        if isinstance(suffix_format, str):
            suffix_format_by_product[product] = suffix_format

    mapping_lines = [
        f'    "{product}": "{suffix_format}",'
        for product, suffix_format in sorted(suffix_format_by_product.items())
    ]
    mapping_body = "\n".join(mapping_lines)
    return (
        "# Auto-generated by generate_contract_suffix_rules.py. Do not edit by hand.\n"
        f"# Source: {source_path}\n\n"
        "from __future__ import annotations\n\n"
        "PRODUCT_SUFFIX_FORMAT: dict[str, str] = {\n"
        f"{mapping_body}\n"
        "}\n\n"
        "YMM_PRODUCTS: frozenset[str] = frozenset(\n"
        '    product for product, suffix_format in PRODUCT_SUFFIX_FORMAT.items() if suffix_format == "YMM"\n'
        ")\n"
    )


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Generate per-product contract suffix format rules from contract data."
    )
    parser.add_argument(
        "--input",
        type=Path,
        default=Path("examples/hz_contracts_data.json"),
        help="Input JSON path. Must be a list of objects containing contractCode.",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=None,
        help="Optional output path. If omitted, prints JSON to stdout.",
    )
    parser.add_argument(
        "--python-output",
        type=Path,
        default=None,
        help="Optional output path for an importable Python rules module.",
    )
    args = parser.parse_args()

    output = generate_rules(args.input)
    rendered = json.dumps(output, ensure_ascii=False, indent=2, sort_keys=True)
    if args.output is None:
        print(rendered)
    else:
        args.output.write_text(rendered + "\n", encoding="utf-8")
        print(f"Wrote rules to {args.output}")

    if args.python_output is not None:
        module_text = render_python_module(output, source_path=args.input)
        args.python_output.write_text(module_text, encoding="utf-8")
        print(f"Wrote python module to {args.python_output}")


if __name__ == "__main__":
    main()
